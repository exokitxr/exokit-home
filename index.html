<!doctype html>
<html>
<head>
  <meta http-equiv="origin-trial" data-feature="WebXR Device API" data-expires="2018-06-16" content="AoTB8rTXnDSsA9/RGdI2Sa447wSkVOywYOhkntuDQVezE/KjftUDR+9laHMmocHsyRewxxbmIgpYIm90ly30TAkAAABgeyJvcmlnaW4iOiJodHRwczovL3dlYm1yLmlvOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkRldmljZSIsImV4cGlyeSI6MTUyOTExMzQxMCwiaXNTdWJkb21haW4iOnRydWV9">
  <meta http-equiv="origin-trial" data-feature="WebXR Gamepad Support" data-expires="2018-06-16" content="At9n2z7AUU4/anCWwNrG+Njzwf3NO71JOKQn64kiLrKNkPTc4T94yOnszPW1iM9E2rzIH8o2t2nVVU70ockSlQcAAABoeyJvcmlnaW4iOiJodHRwczovL3dlYm1yLmlvOjQ0MyIsImZlYXR1cmUiOiJXZWJYUkdhbWVwYWRTdXBwb3J0IiwiZXhwaXJ5IjoxNTI5MTEzNDEwLCJpc1N1YmRvbWFpbiI6dHJ1ZX0=">
  <style>
    body {
      display: flex;
      margin: 0;
      flex-direction: column;
    }
  </style>
</head>
<body>
  <canvas id=canvas></canvas>
  <div id=container></div>
  <script src="js/three.js"></script>
  <script src="js/OBJLoader.js"></script>
  <script src="js/FBXLoader.js"></script>
  <script src="js/inflate.min.js"></script>
  <script src="js/three-ik.js"></script>
  <script src="js/fetch-manager.js"></script>
  <script src="js/vr-display.js"></script>
  <script src="js/tar.js"></script>
  <script src="js/untar.js"></script>
  <script src="js/skin.js"></script>
  <script src="js/model.js"></script>
  <script src="js/sprite3d.js"></script>
  <script src="js/ScreenQuad.js"></script>
  <script src="js/keycode.js"></script>
  <script src="js/svg-boundings.js"></script>
  <script src="js/xrid.js"></script>
  <script src="js/xrmp.js"></script>
  <script src="js/xrmp-three.js"></script>
  <script>
(() => {
    const container = document.getElementById('container');
    const canvas = document.getElementById('canvas');

    const REGISTRY_QUERY_URL = 'https://registry.webmr.io/q';
    const DEFAULT_USER_HEIGHT = 1.6;
    const DEFAULT_SKIN_URL = 'img/skins/male.png';
    const SIDES = ['left', 'right'];
    const FLOOR_SIZE = 20;
    const RAY_COLOR = 0x44c2ff;
    const RAY_HIGHLIGHT_COLOR = new THREE.Color(RAY_COLOR).multiplyScalar(0.5).getHex();
    const rayDistance = 10;
    const menuWidth = 2048;
    const menuHeight = menuWidth;
    const menuWorldWidth = 2;
    const menuWorldHeight = menuWorldWidth * menuHeight / menuWidth;
    const urlBarWidth = menuWidth;
    const tabWidth = 300;
    const urlBarHeight = 200;
    const urlBarOffset = urlBarHeight*1.4;
    const fontSize = 120;
    const keyboardWidth = 2048;
    const keyboardHeight = 716;
    const keyboardMatrix = [keyboardWidth / 963.266, keyboardHeight / 337.215];
    const loadingBarWidth = menuWidth;
    const loadingBarHeight = 200;
    const loadingBarOffset = loadingBarHeight*1.4 + 202;
    let menuOpen = true;
    let fileMeshes = [];
    const fetchManager = new FetchManager();

    const urlState = {
      text: 'http://',
      cursor: -1,
      measures: [],
      submit() {
        currentApps = [urlState.text];
        _updateLocalApps();

        if (_isMpOpen()) {
          xrmp.updateRemoteApps();
        }

        loadingBarState.loaded = false;
        loadingBarState.loading = true;
        loadingBarState.error = false;
        loadingBarState.text = 'Loading...';

        menuMesh.urlMesh.updateText();
      },
    };
    urlState.cursor = urlState.text.length;
    const loadingBarState = {
      text: '',
      loading: false,
      error: false,
      loaded: false,
      value: 0,
      total: 0,
      progress: 0,
    };

    const usernameState = {
      text: 'lol@zol.com',
      cursor: -1,
      measures: [],
      submit() {
        _openLogin();
      },
    };
    usernameState.cursor = usernameState.text.length;
    const passwordState = {
      text: 'zol',
      cursor: -1,
      measures: [],
      submit() {
        _openLogin();
      },
    };
    passwordState.cursor = passwordState.text.length;
    let keyboardState = urlState;
    let controllerIndex = 1;
    const controllerOffsets = [
      new THREE.Vector3(),
      new THREE.Vector3(),
    ];
    const keys = {
      up: false,
      down: false,
      left: false,
      right: false,
      ctrl: false,
      alt: false,
    };

    const upVector = new THREE.Vector3(0, 1, 0);
    const armQuaternionOffset = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, -1));

    const localVector = new THREE.Vector3();
    const localVector2 = new THREE.Vector3();
    const localVector3 = new THREE.Vector3();
    const localVector4 = new THREE.Vector3();
    const localVector5 = new THREE.Vector3();
    const localQuaternion = new THREE.Quaternion();
    const localQuaternion2 = new THREE.Quaternion();
    const localEuler = new THREE.Euler();
    localEuler.order = 'YXZ';
    const localEuler2 = new THREE.Euler();
    localEuler2.order = localEuler.order;
    const localMatrix = new THREE.Matrix4();

    const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10 * 1024);
    camera.position.set(0, DEFAULT_USER_HEIGHT, 1);
    camera.rotation.order = 'YXZ';

    const fakeDisplay = window.navigator.createVRDisplay();
    fakeDisplay.setSize(window.innerWidth * window.devicePixelRatio, window.innerHeight * window.devicePixelRatio);
    fakeDisplay.position.copy(camera.position);
    fakeDisplay.quaternion.copy(camera.quaternion);
    camera.projectionMatrix.toArray(fakeDisplay._frameData.leftProjectionMatrix);
    camera.projectionMatrix.toArray(fakeDisplay._frameData.rightProjectionMatrix);
    fakeDisplay.stereo = false;
    fakeDisplay.update();
    if (window.tickAnimationFrame) {
      fakeDisplay.onrequestanimationframe = fn => window.tickAnimationFrame.window.requestAnimationFrame(fn, 1);
    } else {
      fakeDisplay.onrequestanimationframe = fn => window.requestAnimationFrame(fn, 1);
    }
    fakeDisplay.onvrdisplaypresentchange = () => {
      setTimeout(() => {
        const e = new Event('vrdisplaypresentchange');
        e.display = fakeDisplay;
        window.dispatchEvent(e);
      });
    };
    const _enterFakeDisplay = (stereo = false) => {
      if (fakeDisplay.session) {
        fakeDisplay.session.end();
      }

      fakeDisplay.requestPresent([{source: canvas}])
        .then(() => {
          renderer.vr.setDevice(fakeDisplay);
          renderer.vr.setAnimationLoop(animate);

          if (navigator.xr) {
            const views = !stereo ? [{
              eye: 'left',
              projectionMatrix: fakeDisplay._frameData.leftProjectionMatrix,
              _viewport: {
                x: 0,
                y: 0,
                width: fakeDisplay._width,
                height: fakeDisplay._height,
              },
            }] : [
              {
                eye: 'left',
                projectionMatrix: fakeDisplay._frameData.leftProjectionMatrix,
                _viewport: {
                  x: 0,
                  y: 0,
                  width: fakeDisplay._width / 2,
                  height: fakeDisplay._height,
                },
              },
              {
                eye: 'right',
                projectionMatrix: fakeDisplay._frameData.rightProjectionMatrix,
                _viewport: {
                  x: fakeDisplay._width / 2,
                  y: 0,
                  width: fakeDisplay._width / 2,
                  height: fakeDisplay._height,
                }
              },
            ];
            const devicePose = {
              getViewMatrix(view) {
                return fakeDisplay._frameData[view.eye === 'left' ? 'leftViewMatrix' : 'rightViewMatrix'];
              },
            };
            const frame = {
              views,
              getDevicePose() {
                return devicePose;
              },
            };
            const onends = [];
            const session = {
              addEventListener(e, fn) {
                if (e === 'end') {
                  onends.push(fn);
                }
              },
              baseLayer: null,
              requestFrameOfReference() {
                return Promise.resolve(stereo ? {} : null);
              },
              device: fakeDisplay,
              requestAnimationFrame: fn => window.requestAnimationFrame(timestamp => {
                fn(timestamp, frame);
              }, 1),
              end() {
                for (let i = 0; i < onends.length; i++) {
                  onends[i]();
                }
                return fakeDisplay.exitPresent();
              },
            };
            fakeDisplay.session = session;
            renderer.vr.setSession(session, {
              frameOfReferenceType: 'stage',
            });
          } else {
            window.dispatchEvent(new Event('vrdisplaypresentchange'));
          }

          fakeDisplay.stereo = stereo;
        });
    };
    _enterFakeDisplay();

    const _getGamepads = () => {
      if (fakeDisplay.isPresenting) {
        return fakeDisplay.gamepads;
      } else {
        return navigator.getGamepads();
      }
    };

    let voicechatEnabled = false;
    let xrmp = null;
    const _openMp = url => {
      xrmp = new XRMultiplayerTHREE(new XRMultiplayer(url));
      xrmp.localPlayerMesh = null;
      xrmp.onsync = () => {
        camera.add(xrmp.getAudioListener());

        xrmp.localPlayerMesh = xrmp.createLocalPlayerMesh(undefined, {
          _exokit: {
            username: _isIdOpen() ? xrid.user.username : null,
          },
        });
      };
      xrmp.onclose = () => {
        // console.log('mp close');
      };
      xrmp.onerror = e => {
        console.warn('mp error', e.error);
      };
      xrmp.onplayerenter = playerMesh => {
        const skinMesh = _makeSkinMesh();
        playerMesh.add(skinMesh);

        playerMesh.onupdate = () => {
          skinMesh.update(playerMesh.hmd, playerMesh.gamepads);
        };
        playerMesh.player.onstateupdate = e => {
          const {state} = e;
          const {username} = (state._exokit || {});

          if (username) {
            xrid.get('_exokit.skin', {
              user: username,
              format: 'text',
            })
              .then(skinUrl => {
                skinMesh.setSkinUrl(skinUrl);
              });
          } else {
            skinMesh.setSkinUrl(null);
          }
          console.log('player state update', {state}); // XXX set the skin here
        };

        scene.add(playerMesh);
      };
      xrmp.onplayerleave = playerMesh => {
        scene.remove(playerMesh);
      };
      /* xrmp.onobjectadd = objectMesh => {
        scene.add(objectMesh);
      };
      xrmp.onobjectremove = objectMesh => {
        scene.remove(objectMesh);
      }; */
      xrmp.onstateupdate = e => {
        const {update} = e;

        if (update.apps) {
          currentApps = update.apps;
          _updateLocalApps();
        }
      };
      xrmp.updateRemoteApps = () => {
        xrmp.xrmp.setState({
          apps: currentApps.slice(),
        });
      };
    };
    const _closeMp = () => {
      xrmp.close();

      xrmp = null;
    };
    const _isMpOpen = () => Boolean(xrmp && xrmp.localPlayerMesh);
    const _isIdOpen = () => Boolean(xrid && xrid.user);

    const _openMic = () => {
      navigator.mediaDevices.getUserMedia({
        audio: true,
      })
        .then(mediaStream => {
          xrmp.localPlayerMesh.setMediaStream(mediaStream);
        });
    };
    const _closeMic = () => {
      xrmp.localPlayerMesh.unsetMediaStream();
    };

    const xrid = new XRID('https://id.webmr.io');
    const _openLogin = () => { // XXX
      xrid.login({
        username: 'lol@lol.zol',
        password: 'zol',
      })
        .then(newUser => {
          user = newUser;

          menuMesh.urlMesh.updateText();

          return Promise.all([
            xrid.get('_exokit.skin', 'text')
              .then(skinUrl => localSkinMesh.setSkinUrl(skinUrl)),
            xrid.getFiles()
              .then(newFiles => {
                files = newFiles;

                menuMesh.urlMesh.updateText();
              }),
          ]);

          /* _requestSkinPreviewCanvas(skinUrl)
            .then(canvas => {
              skinPreviewCanvas = canvas;

              menuMesh.urlMesh.updateText();
            }) */
        })
        .catch(err => {
          console.warn(err.stack);
        });
    };
    const _closeLogin = () => {
      user = null;

      menuMesh.urlMesh.updateText();
    };

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const renderer = new THREE.WebGLRenderer({
      canvas,
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.sortObjects = false;
    renderer.vr.enabled = true;

    const _makeRenderTarget = (width, height) => {
      const renderTarget = new THREE.WebGLRenderTarget(width, height);
      renderTarget.depthTexture = new THREE.DepthTexture(
        width,
        height,
        THREE.UnsignedInt248Type,
        THREE.UVMapping,
        THREE.ClampToEdgeWrapping,
        THREE.ClampToEdgeWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        1,
        THREE.DepthStencilFormat
      );
      return renderTarget;
    };
    let renderTarget = _makeRenderTarget(canvas.width, canvas.height);

    const scene = new THREE.Scene();
    const _makeBackground = () => new THREE.Color(0xFFFFFF);
    scene.background = _makeBackground();

    const ambientLight = new THREE.AmbientLight(0x808080);
    scene.add(ambientLight);

    const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
    directionalLight.position.set(1, 1, 1);
    scene.add(directionalLight);

    const _isInBody = p => {
      const hmdEuler = localEuler.setFromQuaternion(camera.quaternion, camera.rotation.order);
      hmdEuler.x = 0;
      hmdEuler.z = 0;
      const hmdQuaternion = localQuaternion.setFromEuler(hmdEuler);
      const bodyPosition = localVector.copy(camera.position)
        .add(
          localVector2.set(0, -0.4, 0.2)
            .applyQuaternion(hmdQuaternion)
        );
      return p.distanceTo(bodyPosition) < 0.35;
    };
    const _makeFileObject = file => {
      const object = new THREE.Object3D();
      object.file = file;

      _requestSpriteMesh('file')
        .then(spriteMesh => {
          object.add(spriteMesh);
        })
        .catch(err => {
          console.warn(err.stack);
        });

      return object;
    };

    const controllerMeshes = [null, null];
    const lastPresseds = [false, false];
    const lastMenuPresseds = [false, false];
    const lastGrabbeds = [false, false];
    const grabbedObjects = [null, null];
    for (let i = 0; i < 2; i++) {
      const controllerMesh = new THREE.Object3D();
      controllerMesh.position.set(i === 0 ? -0.1 : 0.1, 1, 0.5);
      controllerMesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        new THREE.Vector3(0, -1, -1)
      );

      const rayMesh = (() => {
        const geometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 1, 32, 1)
          .applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2))
          .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, -0.5));
        const material = new THREE.MeshBasicMaterial({
          color: RAY_COLOR,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.visible = i === 1;
        return mesh;
      })();
      controllerMesh.add(rayMesh);
      controllerMesh.rayMesh = rayMesh;

      const rayDot = (() => {
        const geometry = new THREE.SphereBufferGeometry(0.01, 5, 5);
        const material = new THREE.MeshBasicMaterial({
          color: 0xe91e63,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.z = -1;
        mesh.visible = false;
        return mesh;
      })();
      controllerMesh.add(rayDot);
      controllerMesh.rayDot = rayDot;

      controllerMesh.ray = new THREE.Ray();
      controllerMesh.update = () => {
        controllerMesh.ray.origin.copy(controllerMesh.position);
        controllerMesh.ray.direction
          .set(0, 0, -1)
          .applyQuaternion(controllerMesh.quaternion);
      };

      scene.add(controllerMesh);
      controllerMeshes[i] = controllerMesh;
    }

    const controllerMeshLoader = new THREE.OBJLoader();
    controllerMeshLoader.setPath('models/obj/vive-controller/');
    controllerMeshLoader.load('vr_controller_vive_1_5.obj', object => {
      const textureLoader = new THREE.TextureLoader();
      textureLoader.setPath('models/obj/vive-controller/');

      const controllerMesh = object.children[0];
      controllerMesh.material.map = textureLoader.load('onepointfive_texture.png');
      controllerMesh.material.specularMap = textureLoader.load('onepointfive_spec.png');

      controllerMeshes[0].add(object.clone());
      controllerMeshes[1].add(object.clone());
    });

    const handMeshes = [null, null];
    const fingerTipGeometry = new THREE.CylinderBufferGeometry(0.001, 0.001, 1, 32, 1)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 1/2, 0));
    const boneGeometry = new THREE.CylinderBufferGeometry(0.002, 0.005, 1, 3);
    const fingerTipMaterial = new THREE.MeshBasicMaterial({
      color: RAY_COLOR,
    });
    const boneMaterial = new THREE.MeshPhongMaterial({
      color: 0x00FF00,
    });
    const _makeHandMesh = () => {
      const handMesh = new THREE.Mesh(fingerTipGeometry, fingerTipMaterial);
      handMesh.visible = false;

      const handFrameData = new Float32Array(new ArrayBuffer(5*4*(3+3) * Float32Array.BYTES_PER_ELEMENT), 0, 5*4*(3+3));
      handMesh.handFrameData = handFrameData;

      const fingerMeshes = Array(5);
      for (let j = 0; j < fingerMeshes.length; j++) {
        const boneMeshes = Array(4);

        for (let k = 0; k < boneMeshes.length; k++) {
          const boneMesh = new THREE.Mesh(boneGeometry, boneMaterial);
          boneMesh.visible = false;
          scene.add(boneMesh);
          boneMeshes[k] = boneMesh;
        }
        fingerMeshes[j] = boneMeshes;
      }

      handMesh.updateFrameData = frameHandData => {
        const palmNormal = localVector.set(frameHandData[3], frameHandData[4], frameHandData[5]);

        if (palmNormal.x !== 0 || palmNormal.y !== 0 || palmNormal.z !== 0) {
          // const palmPosition = localVector.set(frameHandData[0], frameHandData[1], frameHandData[2]);

          const fingerBaseIndex = (1 + 5) * (3 + 3);
          const fingerTipPosition = localVector2.set(frameHandData[fingerBaseIndex], frameHandData[fingerBaseIndex + 1], frameHandData[fingerBaseIndex + 2]);
          const fingerTipDirection = localVector3.set(frameHandData[fingerBaseIndex + 3], frameHandData[fingerBaseIndex + 4], frameHandData[fingerBaseIndex + 5]);

          handMesh.position
            .copy(camera.position)
            .add(
              fingerTipPosition.applyQuaternion(camera.quaternion)
            );
          handMesh.quaternion.setFromUnitVectors(
            upVector,
            fingerTipDirection
          ).premultiply(camera.quaternion);
          handMesh.updateMatrixWorld();
          handMesh.visible = true;

          for (let j = 0; j < fingerMeshes.length; j++) {
            const boneMeshes = fingerMeshes[j];

            for (let k = 0; k < boneMeshes.length; k++) {
              const boneMesh = boneMeshes[k];

              const boneBaseIndex = (1 + 1 + (j * 5) + k) * (3 + 3);
              const boneStartPosition = localVector2
                .copy(camera.position)
                .add(
                  localVector3
                    .set(frameHandData[boneBaseIndex], frameHandData[boneBaseIndex + 1], frameHandData[boneBaseIndex + 2])
                    .applyQuaternion(camera.quaternion)
                );
              const boneEndPosition = localVector3
                .copy(camera.position)
                .add(
                  localVector4
                    .set(frameHandData[boneBaseIndex + 3], frameHandData[boneBaseIndex + 4], frameHandData[boneBaseIndex + 5])
                    .applyQuaternion(camera.quaternion)
                );

              const boneCenter = localVector4
                .copy(boneStartPosition)
                .add(boneEndPosition)
                .divideScalar(2);
              const boneDirection = localVector5
                .copy(boneEndPosition)
                .sub(boneStartPosition);
              const boneLength = boneDirection.length();
              boneDirection.divideScalar(boneLength);

              boneMesh.position.copy(boneCenter);
              boneMesh.quaternion.setFromUnitVectors(
                upVector,
                boneDirection
              );
              boneMesh.scale.y = boneLength;
              boneMesh.updateMatrixWorld();
              boneMesh.visible = true;

              boneStartPosition.toArray(handFrameData, j*4*(3+3) + k*(3+3));
              boneEndPosition.toArray(handFrameData, j*4*(3+3) + k*(3+3) + 3);
            }
          }
        } else {
          handMesh.visible = false;

          for (let j = 0; j < fingerMeshes.length; j++) {
            const boneMeshes = fingerMeshes[j];

            for (let k = 0; k < boneMeshes.length; k++) {
              const boneMesh = boneMeshes[k];
              boneMesh.visible = false;
            }
          }
        }
      };
      handMesh.updatePlayerMatrix = playerMatrixHandData => {
        if (playerMatrixHandData.enabled[0]) {
          for (let j = 0; j < fingerMeshes.length; j++) {
            const boneMeshes = fingerMeshes[j];

            for (let k = 0; k < boneMeshes.length; k++) {
              const boneMesh = boneMeshes[k];

              const boneBaseIndex = ((j*4) + k) * (3+3);
              const boneStartPosition = localVector2.set(playerMatrixHandData.data[boneBaseIndex], playerMatrixHandData.data[boneBaseIndex + 1], playerMatrixHandData.data[boneBaseIndex + 2]);
              const boneEndPosition = localVector3.set(playerMatrixHandData.data[boneBaseIndex + 3], playerMatrixHandData.data[boneBaseIndex + 4], playerMatrixHandData.data[boneBaseIndex + 5]);

              const boneCenter = localVector4
                .copy(boneStartPosition)
                .add(boneEndPosition)
                .divideScalar(2);
              const boneDirection = boneEndPosition
                .sub(boneStartPosition);
              const boneLength = boneDirection.length();
              boneDirection.divideScalar(boneLength);

              boneMesh.position.copy(boneCenter);
              boneMesh.quaternion.setFromUnitVectors(
                upVector,
                boneDirection
              )
              boneMesh.scale.y = boneLength;
              boneMesh.updateMatrixWorld();
              boneMesh.visible = true;
            }
          }
        } else {
          for (let j = 0; j < fingerMeshes.length; j++) {
            const boneMeshes = fingerMeshes[j];

            for (let k = 0; k < boneMeshes.length; k++) {
              const boneMesh = boneMeshes[k];
              boneMesh.visible = false;
            }
          }
        }
      };

      return handMesh;
    };
    for (let i = 0; i < handMeshes.length; i++) {
      const handMesh = _makeHandMesh();
      scene.add(handMesh);
      handMeshes[i] = handMesh;
    }

    const floorMesh = (() => {
      const geometry = new THREE.PlaneBufferGeometry(FLOOR_SIZE, FLOOR_SIZE)
        .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(
          new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 1, 0)
          )
        ));
      const uvs = geometry.attributes.uv.array;
      const numUvs = uvs.length / 2;
      for (let i = 0; i < numUvs; i++) {
        uvs[i * 2] *= FLOOR_SIZE / 10 * 2;
        uvs[i * 2 + 1] *= FLOOR_SIZE / 10;
      }

      const texture = new THREE.Texture(
        null,
        THREE.UVMapping,
        THREE.RepeatWrapping,
        THREE.RepeatWrapping,
        THREE.NearestFilter,
        THREE.NearestFilter,
        THREE.RGBAFormat,
        THREE.UnsignedByteType,
        1
      );

      const graphImg = new Image();
      graphImg.crossOrigin = 'Anonymous';
      graphImg.src = 'img/graphy.png';
      graphImg.onload = () => {
        texture.image = graphImg;
        texture.needsUpdate = true;

        mesh.visible = true;
      };
      graphImg.onerror = err => {
        console.warn(err.stack);
      };

      const material = new THREE.MeshBasicMaterial({
        map: texture,
        side: THREE.DoubleSide,
      });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.visible = false;
      return mesh;
    })();
    scene.add(floorMesh);

    const animations = [];
    const _mod = (v, d) => {
      const n = v % d;
      return n < 0 ? (d + n) : n;
    };
    const _angleDiff = (a, b) => _mod((b - a) + Math.PI, Math.PI * 2) - Math.PI;
    const _makeSkinMesh = () => {
      const object = {};
      let onupdate = null;
      object.setSkinUrl = skinUrl => {
        if (skinUrl) {
          return fetch(skinUrl)
            .then(res => {
              if (res.ok) {
                return Promise.resolve(res);
              } else {
                return Promise.reject(new Error('invalid status code: ' + res.status));
              }
            })
            .then(res => {
              const {headers} = res;
              const type = headers.get('content-type');

              if (/^image\//.test(type)) {
                console.log('set image skin', skinUrl);

                const mesh = skin({
                  limbs: true,
                });

                const uniforms = THREE.UniformsUtils.clone(skin.SKIN_SHADER.uniforms);

                /* const handMeshes = Array(2);
                for (let i = 0; i < handMeshes.length; i++) {
                  const handMesh = _makeHandMesh();
                  scene.add(handMesh);
                  handMeshes[i] = handMesh;
                }
                mesh.handMeshes = handMeshes; */

                mesh.onBeforeRender = (onBeforeRender => function() {
                  mesh.material.uniforms.headRotation.value.copy(uniforms.headRotation.value);
                  mesh.material.uniforms.leftArmRotation.value.copy(uniforms.leftArmRotation.value);
                  mesh.material.uniforms.rightArmRotation.value.copy(uniforms.rightArmRotation.value);
                  mesh.material.uniforms.theta.value = uniforms.theta.value;
                  mesh.material.uniforms.headVisible.value = uniforms.headVisible.value;
                  mesh.material.uniforms.hit.value = uniforms.hit.value;

                  onBeforeRender.apply(this, arguments);
                })(mesh.onBeforeRender);

                return new Promise((accept, reject) => {
                  const skinImg = new Image();
                  skinImg.crossOrigin = 'Anonymous';
                  skinImg.src = skinUrl;
                  skinImg.onload = () => {
                    accept(skinImg);
                  };
                  skinImg.onerror = err => {
                    reject(err);
                  };
                })
                  .then(skinImg => {
                    mesh.setImage(skinImg);

                    onupdate = (hmd, gamepads) => {
                      const hmdEuler = localEuler.setFromQuaternion(hmd.quaternion, localEuler.order);
                      const playerEuler = localEuler2.setFromQuaternion(mesh.quaternion, localEuler2.order);
                      const angleDiff = _angleDiff(hmdEuler.y, playerEuler.y);
                      const angleDiffAbs = Math.abs(angleDiff);
                      if (angleDiffAbs > Math.PI / 2) {
                        playerEuler.y += (angleDiffAbs - (Math.PI / 2)) * (angleDiff < 0 ? 1 : -1);
                        mesh.quaternion.setFromEuler(playerEuler);
                      }

                      const oldWorldPosition = mesh.getWorldPosition(localVector);
                      mesh.position.copy(hmd.position)
                        .sub(mesh.eye.getWorldPosition(localVector2))
                        .add(oldWorldPosition);

                      const playerQuaternionInverse = localQuaternion.copy(mesh.quaternion).inverse();
                      mesh.head.quaternion.copy(playerQuaternionInverse).multiply(hmd.quaternion);
                      mesh.updateMatrixWorld();

                      const headQuaternionInverse = localQuaternion2.copy(mesh.head.quaternion).inverse();
                      uniforms.headRotation.value.set(headQuaternionInverse.x, headQuaternionInverse.y, headQuaternionInverse.z, headQuaternionInverse.w);

                      for (let i = 0; i < 2; i++) {
                        const side = SIDES[i];
                        const armRotation = uniforms[side === 'left' ? 'leftArmRotation' : 'rightArmRotation'];

                        const gamepad = gamepads[i];
                        if (gamepad.visible) {
                          const armQuaternionInverse = localQuaternion2.setFromRotationMatrix(
                            localMatrix.lookAt(
                              mesh.arms[side].getWorldPosition(localVector),
                              gamepad.position,
                              localVector2.copy(upVector).applyQuaternion(gamepad.quaternion)
                            )
                          )
                            .multiply(armQuaternionOffset)
                            .premultiply(playerQuaternionInverse)
                            .inverse();
                          armRotation.value.set(armQuaternionInverse.x, armQuaternionInverse.y, armQuaternionInverse.z, armQuaternionInverse.w);
                        } else {
                          armRotation.value.set(0, 0, 0, 1);
                        }
                      }

                      /* for (let i = 0; i < handMeshes.length; i++) { // XXX
                        handMeshes[i].updatePlayerMatrix(playerMatrix.hands[i]);
                      } */
                    };

                    if (object.skinMesh) {
                      object.skinMesh.parent.remove(object.skinMesh);
                    }

                    scene.add(mesh);
                    object.skinMesh = mesh;
                  });
              } else if (type === 'application/x-tar') {
                console.log('set model skin', skinUrl);

                return res.arrayBuffer()
                  .then(arrayBuffer => untar(arrayBuffer))
                  .then(files => {
                    const fbxFile = files.find(file => /\.fbx/.test(file.name));

                    if (fbxFile) {
                      const directoryUrl = fetchManager.addDirectory(files);
                      const fbxFileUrl = directoryUrl + '/' + fbxFile.name;

                      return THREE.Model.FBX(fbxFileUrl)
                        .then(mesh => {
                         mesh.setHeight(DEFAULT_USER_HEIGHT);

                          onupdate = (hmd, gamepads) => {
                            mesh.update(hmd, gamepads);
                          };

                          if (object.skinMesh) {
                            object.skinMesh.parent.remove(object.skinMesh);
                          }

                          scene.add(mesh);
                          object.skinMesh = mesh;
                        })
                        .catch(err => {
                          console.warn(err.stack);
                        });
                    } else {
                      return Promise.reject(new Error('could not find model file in bundle'));
                    }
                  });
              } else {
                return Promise.reject(new Error('cannot open unknown file type: ' + JSON.stringify(type)));
              }
            });
        } else {
          onupdate = null;

          if (object.skinMesh) {
            object.skinMesh.parent.remove(object.skinMesh);
            object.skinMesh = null;
          }
        }
      };
      object.update = (hmd, gamepads) => {
        onupdate && onupdate(hmd, gamepads);
      };
      object.skinMesh = null;
      return object;
    };

    const localSkinMesh = _makeSkinMesh();
    animations.push(() => {
      localSkinMesh.update(camera, controllerMeshes);
    });

    const _requestSpriteMesh = itemType => new Promise((accept, reject) => {
      const img = new Image();
      img.crossOrigin = 'Anonymous';
      img.src = `img/items/${itemType}.png`;
      img.onload = () => {
        const spriteMesh = sprite3d.makeSpriteMesh(img);
        accept(spriteMesh);
      };
      img.onerror = err => {
        reject(err);
      };
    });

    const tabs = ['URL', 'Files', 'Apps', 'Party', 'Config'];
    const cursorWidth = 10;
    const _getTab = () => {
      if (currentTabIndex >= 0) {
        return tabs[currentTabIndex];
      } else if (currentTabIndex === -2) {
        return 'Login';
      } else {
        return null;
      }
    };
    let apps = [];
    let servers = [];
    let files = [];
    let user = null;
    let currentTabIndex = 0;
    let currentApps = [];
    let currentFileIndex = -1;
    let currentServerIndex = -1;
    const _resJson = res => {
      if (res.ok) {
        return res.json();
      } else {
        return Promise.reject(new Error('invalid status code: ' + res.status));
      }
    };
    (() => {
      fetch(REGISTRY_QUERY_URL)
        .then(_resJson)
        .then(j => {
          const {xrmultiplayerHosts, xrUrls} = j;

          const newServers = [];
          return Promise.all(xrmultiplayerHosts.map(xrmpHost => {
            const prefix = xrmpHost + '/servers';

            return fetch('https://' + prefix)
              .then(_resJson)
              .then(j => {
                const {servers} = j;

                for (let i = 0; i < servers.length; i++) {
                  const server = servers[i];
                  const {name, players, objects} = server;
                  newServers.push({
                    name,
                    url: prefix + '/' + name,
                    players,
                    objects,
                  });
                }
              })
              .catch(err => {
                console.warn(err.stack);
              });
          }))
            .then(() => {
              apps = xrUrls;
              servers = newServers;
            });
        })
        .then(() => {
          menuMesh.urlMesh.updateText();
        })
        .catch(err => {
          console.warn(err.stack);
        });
    })();

    const _requestSkinPreviewCanvas = src => new Promise((accept, reject) => {
      const canvas = document.createElement('canvas');
      canvas.width = 400;
      canvas.height = 800;
      const renderer = new THREE.WebGLRenderer({
        canvas,
        alpha: true,
      });
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(90, 1/2, 0.1, 1024);

      const mesh = skin({
        limbs: true,
      });
      mesh.position.set(0, -1.5/2, -1.2);
      mesh.quaternion.setFromUnitVectors(
        localVector.set(0, 0, -1),
        localVector2.set(0, 0, 1)
      );
      scene.add(mesh);

      const skinImg = new Image();
      skinImg.crossOrigin = 'Anonymous';
      skinImg.src = src;
      skinImg.onload = () => {
        mesh.setImage(skinImg);

        renderer.render(scene, camera);

        accept(canvas);
      };
      skinImg.onerror = err => {
        reject(err);
      };
    });
    let skinPreviewCanvas = null;
    _requestSkinPreviewCanvas(DEFAULT_SKIN_URL)
      .then(canvas => {
        skinPreviewCanvas = canvas;

        menuMesh.urlMesh.updateText();
      });
    const menuMesh = (() => {
      const object = new THREE.Object3D();
      object.position.copy(camera.position).add(new THREE.Vector3(0, 0.5, -2));

      const urlMesh = (() => {
        const canvas = document.createElement('canvas');
        canvas.width = menuWidth;
        canvas.height = menuHeight;
        const ctx = canvas.getContext('2d');

        const geometry = new THREE.PlaneBufferGeometry(menuWorldWidth, menuWorldHeight);
        const texture = new THREE.Texture(
          canvas,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          1
        );
        texture.needsUpdate = true;
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true,
          alphaTest: 0.9,
        });
        const mesh = new THREE.Mesh(geometry, material);

        const _updateText = () => {
          ctx.fillStyle = '#EEE';
          ctx.fillRect(0, 0, menuWidth, menuHeight);

          for (let i = 0; i < tabs.length; i++) {
            ctx.fillStyle = '#333';
            ctx.font = `${fontSize*0.7}px Arial`;
            ctx.fillText(tabs[i], i * tabWidth, urlBarOffset);

            if (i === currentTabIndex) {
              ctx.fillStyle = '#e53935';
              ctx.fillRect(i * tabWidth, urlBarOffset - 10, tabWidth, 10);
            }
          }

          const tab = _getTab();
          if (tab === 'URL') {
            ctx.fillStyle = '#333';
            ctx.fillRect(0, urlBarOffset, urlBarWidth, urlBarHeight);
            ctx.fillStyle = '#FFF';
            ctx.fillRect(5, urlBarOffset + 5, urlBarWidth - 10, urlBarHeight - 10);

            if (loadingBarState.loading && !loadingBarState.error && !loadingBarState.loaded) {
              ctx.fillStyle = '#e68e04';
              ctx.fillRect(0, loadingBarOffset, loadingBarWidth, loadingBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(10, loadingBarOffset, loadingBarWidth -20, loadingBarHeight- 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              ctx.fillText(loadingBarState.text, 10, loadingBarOffset + loadingBarHeight - 10*2 - 30);
            }
            if (loadingBarState.loaded && loadingBarState.error) {
              ctx.fillStyle = '#1dc008';
              ctx.fillRect(0, loadingBarOffset, loadingBarWidth, loadingBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(10, loadingBarOffset, loadingBarWidth -20, loadingBarHeight- 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              ctx.fillText(loadingBarState.text, 10, loadingBarOffset + loadingBarHeight - 10*2 - 30);
            }
            if (loadingBarState.loading && loadingBarState.loaded && loadingBarState.error) {
              ctx.fillStyle = '#ff1818';
              ctx.fillRect(0, loadingBarOffset, loadingBarWidth, loadingBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(10, loadingBarOffset, loadingBarWidth -20, loadingBarHeight- 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              ctx.fillText(loadingBarState.text, 10, loadingBarOffset + loadingBarHeight - 10*2 - 30);
            }

            ctx.fillStyle = '#333';
            ctx.font = `${fontSize}px Arial`;
            ctx.fillText(urlState.text, 10, urlBarOffset + urlBarHeight - 10*2 - 30);

            urlState.measures.length = 0;
            urlState.measures.push(0);
            const {width: barWidth} = ctx.measureText('[');
            for (let i = 1; i <= urlState.text.length; i++) {
              const {width} = ctx.measureText('[' + urlState.text.slice(0, i) + ']');
              urlState.measures.push(width - barWidth*2);
            }

            ctx.fillStyle = '#03a9f4';
            ctx.fillRect(10 + urlState.measures[urlState.cursor] - cursorWidth/2, urlBarOffset + 20, cursorWidth, urlBarHeight - 20*2);
          } else if (tab === 'Files') {
            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              const {url} = file;
              const match = url.match(/([^\/]+)$/);

              const selected = i === currentFileIndex;
              if (selected) {
                ctx.fillStyle = '#03a9f4';
                ctx.fillRect(0, urlBarOffset + i*fontSize, urlBarWidth, fontSize);
              }
              ctx.fillStyle = '#333';
              ctx.fillRect(0, urlBarOffset + i*fontSize, fontSize, fontSize);
              if (selected) {
                ctx.fillStyle = '#FFF';
              }
              ctx.fillText(match[1], fontSize * 1.2, urlBarOffset + (i+1)*fontSize);
              ctx.fillText('x', urlBarWidth - fontSize * 1.2, urlBarOffset + (i+1)*fontSize);
            }
          } else if (tab === 'Apps') {
            for (let i = 0; i < apps.length; i++) {
              const app = apps[i];

              const selected = currentApps.includes(app);
              if (selected) {
                ctx.fillStyle = '#03a9f4';
                ctx.fillRect(0, urlBarOffset + i*fontSize, urlBarWidth, fontSize);
              }
              ctx.fillStyle = '#333';
              ctx.fillRect(0, urlBarOffset + i*fontSize, fontSize, fontSize);
              if (selected) {
                ctx.fillStyle = '#FFF';
              }
              ctx.fillText(app, fontSize * 1.2, urlBarOffset + (i+1)*fontSize);
            }
          } else if (tab === 'Party') {
            for (let i = 0; i < servers.length; i++) {
              const server = servers[i];
              const {url, players, objects} = server;

              const selected = i === currentServerIndex;
              if (selected) {
                ctx.fillStyle = '#03a9f4';
                ctx.fillRect(0, urlBarOffset + i*fontSize, urlBarWidth, fontSize);
              }
              ctx.fillStyle = '#333';
              ctx.fillRect(0, urlBarOffset + i*fontSize, fontSize, fontSize);
              if (selected) {
                ctx.fillStyle = '#FFF';
              }
              ctx.fillText(url, fontSize * 1.2, urlBarOffset + (i+1)*fontSize);
            }
          } else if (tab === 'Config') {
            if (voicechatEnabled) {
              ctx.fillStyle = '#03a9f4';
              ctx.fillRect(0, urlBarOffset, urlBarWidth, fontSize);
              ctx.fillStyle = '#FFF';
            } else {
              ctx.fillStyle = '#333';
            }
            ctx.fillText('Voice', 0, urlBarOffset + fontSize);
          } else if (tab === 'Login') {
            ctx.fillStyle = '#e53935';
            ctx.fillRect(menuWidth - 550, urlBarOffset - 10, tabWidth, 10);

            if (!user) {
              ctx.fillStyle = '#333';
              ctx.fillRect(0, urlBarOffset, urlBarWidth, urlBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(5, urlBarOffset + 5, urlBarWidth - 10, urlBarHeight - 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              ctx.fillText(usernameState.text, 10, urlBarOffset + urlBarHeight - 10*2 - 30);

              usernameState.measures.length = 0;
              usernameState.measures.push(0);
              const {width: usernameWidth} = ctx.measureText('[');
              for (let i = 1; i <= usernameState.text.length; i++) {
                const {width} = ctx.measureText('[' + usernameState.text.slice(0, i) + ']');
                usernameState.measures.push(width - usernameWidth*2);
              }

              ctx.fillStyle = '#03a9f4';
              ctx.fillRect(10 + usernameState.measures[usernameState.cursor] - cursorWidth/2, urlBarOffset + 20, cursorWidth, urlBarHeight - 20*2);

              ctx.fillStyle = '#333';
              ctx.fillRect(0, urlBarOffset*2, urlBarWidth, urlBarHeight);
              ctx.fillStyle = '#FFF';
              ctx.fillRect(5, urlBarOffset*2 + 5, urlBarWidth - 10, urlBarHeight - 10);
              ctx.fillStyle = '#333';
              ctx.font = `${fontSize}px Arial`;
              const passwordText = '*'.repeat(passwordState.text.length);
              ctx.fillText(passwordText, 10, urlBarOffset*2 + urlBarHeight - 10*2 - 30);

              passwordState.measures.length = 0;
              passwordState.measures.push(0);
              const {width: passwordWidth} = ctx.measureText('[');
              for (let i = 1; i <= passwordText.length; i++) {
                const {width} = ctx.measureText('[' + passwordText.slice(0, i) + ']');
                passwordState.measures.push(width - passwordWidth*2);
              }

              ctx.fillStyle = '#03a9f4';
              ctx.fillRect(10 + passwordState.measures[passwordState.cursor] - cursorWidth/2, urlBarOffset*2 + 20, cursorWidth, urlBarHeight - 20*2);

              ctx.fillStyle = '#333';
              ctx.fillRect(0, urlBarOffset*3, 300, fontSize);
              ctx.fillStyle = '#FFF';
              ctx.font = `${fontSize*0.5}px Arial`;
              ctx.fillText('Login', 70, urlBarOffset*3 + 80);
            } else {
              ctx.fillStyle = '#333';
              ctx.fillRect(0, urlBarOffset, 300, fontSize);
              ctx.fillStyle = '#FFF';
              ctx.font = `${fontSize*0.5}px Arial`;
              ctx.fillText('Logout', 50, urlBarOffset + 80);

              if (skinPreviewCanvas) {
                ctx.drawImage(skinPreviewCanvas, 0, urlBarOffset*2);
              }
              ctx.fillStyle = '#333';
            }
          }

          if (tab === 'URL' || tab === 'Apps') {
            if (loadingBarState.progress < 1) {
              ctx.fillStyle = '#2196F3';
              ctx.fillRect(0, 0, loadingBarWidth * loadingBarState.progress, 10);
            }
          }

          ctx.font = `${fontSize*0.7}px Arial`;
          if (!user) {
            ctx.fillStyle = '#333';
            ctx.fillText('Not logged in', menuWidth - 550, urlBarOffset);
          } else {
            ctx.fillStyle = '#333';
            ctx.fillRect(menuWidth - 550, urlBarOffset - 100, 100, 100);
            ctx.fillText(user.username, menuWidth - 550 + 100 + 20, urlBarOffset);
          }

          texture.needsUpdate = true;
        };
        _updateText();
        mesh.updateText = _updateText;

        mesh.plane = new THREE.Plane();
        mesh.leftLine = new THREE.Line3();
        mesh.topLine = new THREE.Line3();
        mesh.update = () => {
          mesh.leftLine.start
            .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
            .applyMatrix4(mesh.matrixWorld);
          mesh.leftLine.end
            .set(-menuWorldWidth/2, -menuWorldHeight/2, 0)
            .applyMatrix4(mesh.matrixWorld);

          mesh.topLine.start
            .set(-menuWorldWidth/2, menuWorldHeight/2, 0)
            .applyMatrix4(mesh.matrixWorld);
          mesh.topLine.end
            .set(menuWorldWidth/2, menuWorldHeight / 2, 0)
            .applyMatrix4(mesh.matrixWorld);

          mesh.plane.setFromCoplanarPoints(
            mesh.leftLine.start,
            mesh.leftLine.end,
            mesh.topLine.end
          );
        };

        return mesh;
      })();
      object.add(urlMesh);
      object.urlMesh = urlMesh;

      return object;
    })();
    scene.add(menuMesh);

    const keyboardMesh = (() => {
      const object = new THREE.Object3D();

      const planeMesh = (() => {
        const img = new Image();
        img.crossOrigin = 'Anonymous';
        img.src = 'img/keyboard.png';
        img.onload = () => {
          texture.needsUpdate = true;
        };
        img.onerror = err => {
          console.warn(err.stack);
        };

        const geometry = new THREE.PlaneBufferGeometry(1, keyboardHeight / keyboardWidth);
        const texture = new THREE.Texture(
          img,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          1
        );
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true,
          alphaTest: 0.9,
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.quaternion.setFromUnitVectors(
          new THREE.Vector3(0, 0, 1),
          new THREE.Vector3(0, 1, 1).normalize()
        );
        return mesh;
      })();
      object.add(planeMesh);
      object.planeMesh = planeMesh;

      object.plane = new THREE.Plane();
      object.leftLine = new THREE.Line3();
      object.topLine = new THREE.Line3();
      object.update = () => {
        object.leftLine.start
          .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);
        object.leftLine.end
          .set(-1/2, -keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);

        object.topLine.start
          .set(-1/2, keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);
        object.topLine.end
          .set(1/2, keyboardHeight / keyboardWidth / 2, 0)
          .applyMatrix4(planeMesh.matrixWorld);

        object.plane.setFromCoplanarPoints(
          object.leftLine.start,
          object.leftLine.end,
          object.topLine.end
        );
      };

      return object;
    })();
    keyboardMesh.position.set(0, 0.5, 0);
    scene.add(keyboardMesh);

    let keyboardMeshAnimation = null;

    for (let i = 0; i < controllerMeshes.length; i++) {
      const controllerMesh = controllerMeshes[i];

      const keyMesh = (() => {
        const geometry = new THREE.PlaneBufferGeometry(1, 1);
        const texture = new THREE.Texture(
          null,
          THREE.UVMapping,
          THREE.ClampToEdgeWrapping,
          THREE.ClampToEdgeWrapping,
          THREE.NearestFilter,
          THREE.NearestFilter,
          THREE.RGBAFormat,
          THREE.UnsignedByteType,
          1
        );
        const material = new THREE.MeshBasicMaterial({
          map: texture,
          side: THREE.DoubleSide,
          transparent: true,
        });
        const mesh = new THREE.Mesh(geometry, material);
        return mesh;
      })();
      keyboardMesh.planeMesh.add(keyMesh);

      controllerMesh.keyMesh = keyMesh;
    }

    let keyboardHighlightCanvasCtx = null;
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = 'img/keyboard-hightlight.svg';
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0);
      keyboardHighlightCanvasCtx = ctx;
    };
    img.onerror = err => {
      console.log(err.stack);
    };

    const keyMap = [];
    fetch('img/keyboard.svg')
      .then(res => res.text())
      .then(keyboardText => {
        const div = document.createElement('div');
        div.innerHTML = keyboardText;
        const keyEls = div.querySelectorAll('svg > g[key]');
        for (let i = 0; i < keyEls.length; i++) {
          const keyEl = keyEls[i];
          const key = keyEl.getAttribute('key');
          const shapeEl = keyEl.children[0];
          const boundings = svgBoundings[shapeEl.tagName.toLowerCase()](shapeEl);
          const {
            left,
            right,
            top,
            bottom,
          } = boundings;
          const x1 = left * keyboardMatrix[0];
          const x2 = right * keyboardMatrix[0];
          const y1 = top * keyboardMatrix[1];
          const y2 = bottom * keyboardMatrix[1];
          keyMap.push([key, x1, y1, x2, y2]);
        }
      })
      .catch(err => {
        console.warn(err.stack);
      });

    const compositeScene = new THREE.Scene();

    const screenQuad = new ScreenQuad({
      texture1: renderTarget.texture,
      depth1: renderTarget.depthTexture,
    });
    let framebuffer = null;
    compositeScene.add(screenQuad);

    const position = new THREE.Vector3();
    const velocity = new THREE.Vector3();
    const speed = 0.0001;
    let lastTime = Date.now();
    const _updateGamepads = () => {
      for (let i = 0; i < 2; i++) {
        const gamepad = fakeDisplay.gamepads[i];
        if (gamepad) {
          const controllerOffset = controllerOffsets[i];

          localVector.copy(fakeDisplay.position)
            .add(
              localVector2.set(-0.1 + (i*0.1*2), -0.1, -0.2)
                .add(controllerOffset)
                .applyQuaternion(fakeDisplay.quaternion)
            ).toArray(gamepad.pose.position);
          fakeDisplay.quaternion.toArray(fakeDisplay.gamepads[i].pose.orientation);
        }
      }
    };
    const _render = () => {
      if (framebuffer) {
        framebuffer.render();
      }

      const device = renderer.vr.getDevice();
      if (device && device.constructor.name === 'FakeVRDisplay') {
        camera.position.copy(device.position);
        camera.quaternion.copy(device.quaternion);

        renderer.render(scene, camera, renderTarget);
      } else {
        renderer.render(scene, camera, renderTarget);
      }

      renderer.vr.enabled = false;
      renderer.render(compositeScene, camera);
      renderer.vr.enabled = true;
    };
    function animate() {
      const currentTime = Date.now();
      const timePassed = Math.max(currentTime - lastTime, 1);
      lastTime = currentTime;

      const _updateMovement = () => {
        if (window.document.pointerLockElement) {
          let moving = false;
          if (keys.up) {
            velocity.z -= speed * timePassed;
            moving = true;
          }
          if (keys.down) {
            velocity.z += speed * timePassed;
            moving = true;
          }
          if (keys.left) {
            velocity.x -= speed * timePassed;
            moving = true;
          }
          if (keys.right) {
            velocity.x += speed * timePassed;
            moving = true;
          }
          velocity.multiplyScalar(Math.pow(moving ? 0.98 : 0.91, timePassed / 5));
          localEuler.setFromQuaternion(fakeDisplay.quaternion, localEuler.order);
          localEuler.x = 0;
          fakeDisplay.position.add(
            localVector.copy(velocity)
              .applyEuler(localEuler)
          );

          fakeDisplay.update();

          _updateGamepads();
        }
      };
      const _updateControllers = () => {
        const gamepads = _getGamepads();

        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          if (gamepad) {
            const controllerMesh = controllerMeshes[i];
            controllerMesh.position.fromArray(gamepad.pose.position);
            controllerMesh.quaternion.fromArray(gamepad.pose.orientation);
            controllerMesh.updateMatrixWorld();
          }
        }
      };
      const _updateHands = () => {
        if (renderer.vr.frameData && renderer.vr.frameData.hands) {
          for (let i = 0; i < renderer.vr.frameData.hands.length; i++) {
            handMeshes[i].updateFrameData(renderer.vr.frameData.hands[i]);
          }
        }
      };
      const _updateIntersections = () => {
        keyboardMesh.update();
        menuMesh.urlMesh.update();

        const gamepads = _getGamepads();

        (() => {
          const controllerMesh = controllerMeshes[controllerIndex];
          controllerMesh.update();

          const gamepad = gamepads[controllerIndex];
          let pressed = false;
          let grabbed = false;
          let menuPressed = false;
          if (gamepad) {
            pressed = gamepad.buttons[1].pressed;
            grabbed = gamepad.buttons[2].pressed;
            menuPressed = gamepad.buttons[3].pressed;
          }

          const _setIntersectionDefault = () => {
            controllerMesh.rayMesh.scale.z = rayDistance;
            controllerMesh.rayMesh.updateMatrixWorld();

            controllerMesh.rayDot.visible = false;

            controllerMesh.keyMesh.visible = false;
          };

          // keyboard
          let intersectionKey = null;
          let intersectionPoint = keyboardMesh.visible ? controllerMesh.ray.intersectPlane(keyboardMesh.plane, localVector) : null;
          if (intersectionPoint) {
            const leftIntersectionPoint = keyboardMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

            const topIntersectionPoint = keyboardMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

            const xFactor = topIntersectionPoint.distanceTo(keyboardMesh.topLine.start) / (1);
            const yFactor = leftIntersectionPoint.distanceTo(keyboardMesh.leftLine.start) / (keyboardHeight / keyboardWidth);
            const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

            if (xFactor > 0 && xFactor <= 0.99 && yFactor > 0 && yFactor <= 0.99 && distance < rayDistance) {
              const x = xFactor * keyboardWidth;
              const y = yFactor * keyboardHeight;

              controllerMesh.rayMesh.scale.z = distance;
              controllerMesh.updateMatrixWorld();

              controllerMesh.rayDot.position.z = -distance;
              controllerMesh.updateMatrixWorld();
              controllerMesh.rayDot.visible = true;

              for (let i = 0; i < keyMap.length; i++) {
                const [key, kx1, ky1, kx2, ky2] = keyMap[i];
                if (x >= kx1 && x < kx2 && y >= ky1 && y < ky2) {
                  if (keyboardHighlightCanvasCtx) {
                    const width = kx2 - kx1;
                    const height = ky2 - ky1;
                    let imageData = keyboardHighlightCanvasCtx.getImageData(kx1, ky1, width, height);
                    /* if (key === 'enter') { // special case the enter key; it has a non-rectangular shape
                      const canvas = document.createElement('canvas');
                      canvas.width = imageData.width;
                      canvas.height = imageData.height;

                      const ctx = canvas.getContext('2d');
                      ctx.putImageData(imageData, 0, 0);
                      ctx.clearRect(0, 0, 80, 140);

                      imageData = ctx.getImageData(0, 0, imageData.width, imageData.height);
                    } */

                    controllerMesh.keyMesh.material.map.image = imageData;
                    controllerMesh.keyMesh.material.map.needsUpdate = true;

                    controllerMesh.keyMesh.position
                      .set(
                        -1/2 + ((width/2 + kx1) / keyboardWidth),
                        (keyboardHeight / keyboardWidth)/2 - ((height/2 + ky1) / keyboardHeight * (keyboardHeight / keyboardWidth)),
                         0.01 * (pressed ? 0.5 : 1)
                      );
                    controllerMesh.keyMesh.scale.set(
                      width / keyboardWidth,
                      height / keyboardHeight * (keyboardHeight / keyboardWidth),
                      1
                    );
                    controllerMesh.keyMesh.updateMatrixWorld();
                    controllerMesh.keyMesh.visible = true;
                  }

                  intersectionKey = key;

                  break;
                }
              }
            } else {
              intersectionPoint = null;
            }
          }

          // menu mesh
          let tabIndex = -1;
          let urlCoords = null;
          let appIndex = -1;
          let fileIndex = -1;
          let fileRemove = false;
          let serverIndex = -1;
          let loginHovered = false;
          let voicechatHovered = false;
          let loginCoords = null;
          if (!intersectionPoint) {
            intersectionPoint = menuMesh.visible ? controllerMesh.ray.intersectPlane(menuMesh.urlMesh.plane, localVector) : null;
            if (intersectionPoint) {
              const leftIntersectionPoint = menuMesh.urlMesh.leftLine.closestPointToPoint(intersectionPoint, true, localVector2);

              const topIntersectionPoint = menuMesh.urlMesh.topLine.closestPointToPoint(intersectionPoint, true, localVector3);

              const xFactor = topIntersectionPoint.distanceTo(menuMesh.urlMesh.topLine.start) / menuWorldWidth;
              const yFactor = leftIntersectionPoint.distanceTo(menuMesh.urlMesh.leftLine.start) / menuWorldHeight;
              const distance = controllerMesh.ray.origin.distanceTo(intersectionPoint);

              if (xFactor > 0 && xFactor <= 0.99 && yFactor > 0 && yFactor <= 0.99 && distance < rayDistance) {
                const x = xFactor * menuWidth;
                const y = yFactor * menuHeight;

                const tab = _getTab();
                if (y < urlBarOffset) {
                  const newTabIndex = Math.floor(x / tabWidth);
                  if (newTabIndex < tabs.length) {
                    tabIndex = newTabIndex;

                    controllerMesh.rayMesh.scale.z = distance;
                    controllerMesh.updateMatrixWorld();

                    controllerMesh.rayDot.position.z = -distance;
                    controllerMesh.updateMatrixWorld();
                    controllerMesh.rayDot.visible = true;
                  } else {
                    const xLeft = menuWidth - 550;

                    if (x > xLeft) {
                      loginHovered = true;

                      controllerMesh.rayMesh.scale.z = distance;
                      controllerMesh.updateMatrixWorld();

                      controllerMesh.rayDot.position.z = -distance;
                      controllerMesh.updateMatrixWorld();
                      controllerMesh.rayDot.visible = true;
                    } else {
                      intersectionPoint = null;
                    }
                  }
                } else {
                  if (tab === 'URL') {
                    if (y < urlBarOffset*2) {
                      urlCoords = [x, y];

                      controllerMesh.rayMesh.scale.z = distance;
                      controllerMesh.updateMatrixWorld();

                      controllerMesh.rayDot.position.z = -distance;
                      controllerMesh.updateMatrixWorld();
                      controllerMesh.rayDot.visible = true;
                    } else {
                      intersectionPoint = null;
                    }
                  } else if (tab === 'Files') {
                    let j = 0;
                    for (j = 0; j < files.length; j++) {
                      const yTop = urlBarOffset + j*fontSize;
                      const yBottom = urlBarOffset + (j+1)*fontSize;

                      if (y >= yTop && y < yBottom) {
                        fileIndex = j;

                        if (x >= menuWidth * 0.9) {
                          fileRemove = true;
                        }

                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        controllerMesh.rayDot.position.z = -distance;
                        controllerMesh.updateMatrixWorld();
                        controllerMesh.rayDot.visible = true;

                        break;
                      }
                    }
                    if (j === files.length) {
                      intersectionPoint = null;
                    }
                  } else if (tab === 'Apps') {
                    let j = 0;
                    for (j = 0; j < apps.length; j++) {
                      const yTop = urlBarOffset + j*fontSize;
                      const yBottom = urlBarOffset + (j+1)*fontSize;

                      if (y >= yTop && y < yBottom) {
                        appIndex = j;

                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        controllerMesh.rayDot.position.z = -distance;
                        controllerMesh.updateMatrixWorld();
                        controllerMesh.rayDot.visible = true;

                        break;
                      }
                    }
                    if (j === apps.length) {
                      intersectionPoint = null;
                    }
                  } else if (tab === 'Party') {
                    let j = 0;
                    for (j = 0; j < servers.length; j++) {
                      const yTop = urlBarOffset + j*fontSize;
                      const yBottom = urlBarOffset + (j+1)*fontSize;

                      if (y >= yTop && y < yBottom) {
                        serverIndex = j;

                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        controllerMesh.rayDot.position.z = -distance;
                        controllerMesh.updateMatrixWorld();
                        controllerMesh.rayDot.visible = true;

                        break;
                      }
                    }
                    if (j === servers.length) {
                      intersectionPoint = null;
                    }
                  } else if (tab === 'Config') {
                    const yTop = urlBarOffset;
                    const yBottom = urlBarOffset + fontSize;

                    if (y >= yTop && y < yBottom) {
                      voicechatHovered = true;

                      controllerMesh.rayMesh.scale.z = distance;
                      controllerMesh.updateMatrixWorld();

                      controllerMesh.rayDot.position.z = -distance;
                      controllerMesh.updateMatrixWorld();
                      controllerMesh.rayDot.visible = true;
                    } else {
                      intersectionPoint = null;
                    }
                  } else if (tab === 'Login') {
                    if (!user) {
                      const fieldIndex = Math.floor((y - urlBarOffset) / urlBarOffset);

                      if (fieldIndex < 3) {
                        loginCoords = [fieldIndex, x, y];

                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        controllerMesh.rayDot.position.z = -distance;
                        controllerMesh.updateMatrixWorld();
                        controllerMesh.rayDot.visible = true;
                      } else {
                        intersectionPoint = null;
                      }
                    } else {
                      const fieldIndex = Math.floor((y - urlBarOffset) / urlBarOffset);

                      if (fieldIndex < 1) {
                        loginCoords = [fieldIndex, x, y];

                        controllerMesh.rayMesh.scale.z = distance;
                        controllerMesh.updateMatrixWorld();

                        controllerMesh.rayDot.position.z = -distance;
                        controllerMesh.updateMatrixWorld();
                        controllerMesh.rayDot.visible = true;
                      } else {
                        intersectionPoint = null;
                      }
                    }
                  } else {
                    intersectionPoint = null;
                  }
                }
              } else {
                intersectionPoint = null;
              }
            }
          }

          if (!intersectionPoint) {
            _setIntersectionDefault();
          }

          const lastMenuPressed = lastMenuPresseds[controllerIndex];
          lastMenuPresseds[controllerIndex] = menuPressed;
          if (menuPressed && !lastMenuPressed) {
            const opening = !menuOpen;
            if (opening) {
              localEuler.setFromQuaternion(camera.quaternion, localEuler.order);
              localEuler.x = 0;
              localEuler.z = 0;

              keyboardMesh.position
                .copy(camera.position)
                .add(
                  localVector
                    .set(0, -0.5, -1)
                    .applyEuler(localEuler)
                );

              menuMesh.position
                .copy(camera.position)
                .add(
                  localVector
                    .set(0, 0.5, -2)
                    .applyEuler(localEuler)
                );

              controllerMeshes[controllerIndex].rayMesh.visible = true;
            } else {
              controllerMeshes[controllerIndex].rayMesh.visible = false;
            }
            menuOpen = opening;

            if (opening) {
              localEuler.setFromQuaternion(
                localQuaternion
                  .setFromUnitVectors(
                    new THREE.Vector3(0, 0, -1),
                    keyboardMesh.position.clone()
                      .sub(camera.position)
                      .normalize()
                  ),
                localEuler.order
              );
              localEuler.x = 0;
              localEuler.z = 0;
              keyboardMesh.rotation.copy(localEuler);
              menuMesh.rotation.copy(localEuler);
            }

            const endValue = opening ? 1 : 0;
            const now = Date.now();
            keyboardMeshAnimation = {
              startValue: keyboardMesh.planeMesh.scale.y,
              endValue,
              startTime: now,
              endTime: now + 300,
            };
          }

          const lastGrabbed = lastGrabbeds[controllerIndex];
          lastGrabbeds[controllerIndex] = grabbed;
          if (grabbed && !lastGrabbed) {
            const targetObject = fileMeshes.find(objectMesh =>
              objectMesh.position.distanceTo(controllerMesh.position) < 0.1
            );
            if (targetObject) {
              grabbedObjects[controllerIndex] = targetObject;
            } else if (_isInBody(controllerMesh.position) && currentFileIndex !== -1) {
              const currentFile = files[currentFileIndex];
              const fileObject = _makeFileObject(currentFile);
              scene.add(fileObject);
              fileMeshes.push(fileObject);

              grabbedObjects[controllerIndex] = fileObject;
            }
          } else if (!grabbed && lastGrabbed) {
            const grabbedObject = grabbedObjects[controllerIndex];

            if (grabbedObject) {
              if (_isInBody(controllerMesh.position)) {
                scene.remove(grabbedObject);
                fileMeshes.splice(fileMeshes.indexOf(grabbedObject), 1);
              }

              grabbedObjects[controllerIndex] = null;
            }
          }

          const lastPressed = lastPresseds[controllerIndex];
          lastPresseds[controllerIndex] = pressed;
          if (pressed && !lastPressed) {
            if (gamepad.hapticActuators) {
              for (let j = 0; j < gamepad.hapticActuators.length; j++) {
                gamepad.hapticActuators[j].pulse(1, 100);
              }
            }

            const grabbedObject = grabbedObjects[controllerIndex];
            if (grabbedObject) {
              const {file} = grabbedObject;

              if (_isIdOpen()) {
                Promise.all([
                  xrid.set('_exokit.skin', file.url)
                    .then(() => {
                      if (_isMpOpen()) {
                        return xrmp.localPlayerMesh.player.setState({
                          username: xrid.user.username,
                        });
                      }
                    }),
                  localSkinMesh.setSkinUrl(file.url),
                  /* _requestSkinPreviewCanvas(file.url)
                    .then(canvas => {
                      skinPreviewCanvas = canvas;

                      menuMesh.urlMesh.updateText();
                    }), */
                ])
                  .catch(err => {
                    console.warn(err);
                  });
              }
            } else if (intersectionKey) {
              const code = keyCode(intersectionKey);
              _handleKey(code, false);
            } else if (tabIndex !== -1) {
              currentTabIndex = tabIndex;

              const tab = _getTab();
              if (tab === 'URL') {
                keyboardState = urlState;
              } else if (tab === 'Login') {
                keyboardState = usernameState;
              }

              menuMesh.urlMesh.updateText();
            } else if (loginHovered) {
              currentTabIndex = -2;

              menuMesh.urlMesh.updateText();
            } else if (urlCoords) {
              const [x, y] = urlCoords;
              const textX = x - 10;

              let closestIndex = -1;
              let closestDistance = Infinity;
              for (let i = 0; i < urlState.measures.length; i++) {
                const urlMeasure = urlState.measures[i];
                const distance = Math.abs(urlMeasure - textX);
                if (distance < closestDistance) {
                  closestIndex = i;
                  closestDistance = distance;
                }
              }
              if (closestIndex !== -1) {
                urlState.cursor = closestIndex;
                menuMesh.urlMesh.updateText();
              }

              keyboardState = urlState;
            } else if (appIndex !== -1) {
              const app = apps[appIndex];
              const currentAppIndex = currentApps.indexOf(app);
              if (currentAppIndex === -1) {
                currentApps = [app];
                _updateLocalApps();
              } else {
                currentApps.splice(currentAppIndex, 1);
                _updateLocalApps();
              }

              if (_isMpOpen()) {
                xrmp.updateRemoteApps();
              }

              menuMesh.urlMesh.updateText();
            } else if (fileIndex !== -1) {
              if (currentFileIndex === fileIndex && fileRemove) {
                if (_isIdOpen()) {
                  const file = files[fileIndex];
                  files.splice(fileIndex, 1);
                  fileMeshes = fileMeshes.filter(fileObject => {
                    if (fileObject.file.url === file.url) {
                      scene.remove(fileObject);
                      return false;
                    } else {
                      return true;
                    }
                  });

                  currentFileIndex = -1;

                  xrid.remove(file.name)
                    .catch(err => {
                      console.warn(err.stack);
                    });

                  menuMesh.urlMesh.updateText();
                }
              } else {
                currentFileIndex = fileIndex;

                menuMesh.urlMesh.updateText();
              }
            } else if (serverIndex !== -1) {
              if (currentServerIndex !== serverIndex) {
                currentServerIndex = serverIndex;

                _openMp(window.location.protocol.replace(/^http/, 'ws') + '//' + servers[serverIndex].url);
              } else {
                currentServerIndex = -1;

                _closeMp();
                voicechatEnabled = false;

                currentApps = [];
                _updateLocalApps();
              }

              menuMesh.urlMesh.updateText();
            } else if (voicechatHovered) {
              if (_isMpOpen()) {
                if (!voicechatEnabled) {
                  _openMic();
                  voicechatEnabled = true;

                  menuMesh.urlMesh.updateText();
                } else {
                  _closeMic();
                  voicechatEnabled = false;

                  menuMesh.urlMesh.updateText();
                }
              }
            } else if (loginCoords) {
              const [fieldIndex, x, y] = loginCoords;

              if (!user) {
                if (fieldIndex === 0) {
                  const textX = x - 10;

                  let closestIndex = -1;
                  let closestDistance = Infinity;
                  for (let i = 0; i < usernameState.measures.length; i++) {
                    const usernameMeasure = usernameState.measures[i];
                    const distance = Math.abs(usernameMeasure - textX);
                    if (distance < closestDistance) {
                      closestIndex = i;
                      closestDistance = distance;
                    }
                  }
                  if (closestIndex !== -1) {
                    usernameState.cursor = closestIndex;
                    menuMesh.urlMesh.updateText();
                  }

                  keyboardState = usernameState;
                } else if (fieldIndex === 1) {
                  const textX = x - 10;

                  let closestIndex = -1;
                  let closestDistance = Infinity;
                  for (let i = 0; i < passwordState.measures.length; i++) {
                    const passwordMeasure = passwordState.measures[i];
                    const distance = Math.abs(passwordMeasure - textX);
                    if (distance < closestDistance) {
                      closestIndex = i;
                      closestDistance = distance;
                    }
                  }
                  if (closestIndex !== -1) {
                    passwordState.cursor = closestIndex;
                    menuMesh.urlMesh.updateText();
                  }

                  keyboardState = passwordState;
                } else if (fieldIndex === 2) {
                  _openLogin();
                }
              } else {
                if (fieldIndex === 0) {
                  _closeLogin();
                }
              }
            }
          }
        })();
      };
      const _animateKeyboard = () => {
        if (keyboardMeshAnimation) {
          const now = Date.now();
          const factor = Math.pow((now - keyboardMeshAnimation.startTime) / (keyboardMeshAnimation.endTime - keyboardMeshAnimation.startTime), 0.15);

          if (factor < 1) {
            const scaleY = keyboardMeshAnimation.startValue * (1 - factor) + keyboardMeshAnimation.endValue * factor;

            keyboardMesh.planeMesh.scale.y = scaleY;
            keyboardMesh.updateMatrixWorld();
            keyboardMesh.visible = true;

            menuMesh.scale.y = scaleY;
            menuMesh.updateMatrixWorld();
            menuMesh.visible = true;
          } else {
            const visible = keyboardMesh.planeMesh.scale.y > 0.5;
            keyboardMesh.visible = visible;
            menuMesh.visible = visible;

            keyboardMeshAnimation = null;
          }
        }
      };
      const _animateControllers = () => {
        const gamepads = _getGamepads();

        const controllersVisible = menuOpen || iframes.length === 0;
        for (let i = 0; i < gamepads.length; i++) {
          const gamepad = gamepads[i];
          const controllerMesh = controllerMeshes[i];
          if (gamepad && controllersVisible) {
            const {pressed} = gamepad.buttons[1];
            controllerMesh.rayMesh.material.color.setHex(pressed ? RAY_HIGHLIGHT_COLOR : RAY_COLOR);
            controllerMesh.visible = true;
          } else {
            controllerMesh.visible = false;
          }
        }

        /* const loopTime = 1500;
        for (let i = 0; i < controllerMeshes.length; i++) {
          const controllerMesh = controllerMeshes[i];
          localEuler.y = (i === 0 ? -1 : 1) * Math.sin((currentTime % loopTime) / loopTime * Math.PI * 2);
          controllerMesh.quaternion.setFromUnitVectors(
            localVector.set(0, 0, -1),
            localVector2.set(0, -1, -1)
              .normalize()
              .applyEuler(
                localEuler
              )
          );
        } */
      };
      const _updateObjects = () => {
        const gamepads = _getGamepads();
        for (let i = 0; i < 2; i++) {
          const grabbedObject = grabbedObjects[i];

          if (grabbedObject) {
            const gamepad = gamepads[i];

            grabbedObject.position.fromArray(gamepad.pose.position);
            grabbedObject.quaternion.fromArray(gamepad.pose.orientation);
            grabbedObject.updateMatrixWorld();

            /* if (_isMpOpen()) {
              objectMesh.position.toArray(objectMesh.object.objectMatrix.position);
              objectMesh.quaternion.toArray(objectMesh.object.objectMatrix.quaternion);

              objectMesh.object.pushUpdate();
            } */
          }
        }
      };
      const _animateAnimations = () => {
        for (let i = 0; i < animations.length; i++) {
          animations[i]();
        }
      };
      const _updateMp = () => {
        if (_isMpOpen()) {
          xrmp.localPlayerMesh.hmd.position.copy(camera.position);
          xrmp.localPlayerMesh.hmd.quaternion.copy(camera.quaternion);

          for (let i = 0; i < 2; i++) {
            const controllerMesh = controllerMeshes[i];
            xrmp.localPlayerMesh.gamepads[i].visible = true;
            xrmp.localPlayerMesh.gamepads[i].position.copy(controllerMesh.position);
            xrmp.localPlayerMesh.gamepads[i].quaternion.copy(controllerMesh.quaternion);
          }

          /* for (let i = 0; i < 2; i++) { // XXX
            xrmp.localPlayer.playerMatrix.hands[i].enabled[0] = +handMeshes[i].visible;
            xrmp.localPlayer.playerMatrix.hands[i].data.set(handMeshes[i].handFrameData);
          } */

          xrmp.pushUpdate();
        }
      };
      _updateMovement();
      _updateControllers();
      _updateHands();
      _updateIntersections();
      _animateKeyboard();
      _animateControllers();
      _animateAnimations();
      _updateObjects();
      _updateMp();

      if (window.requestAnimationFrame.length === 1) {
        _render();
      }

      if (!renderer.vr.getDevice()) {
        window.requestAnimationFrame(animate, 1);
      }
    }

    if (window.requestAnimationFrame.length === 2) {
      (function recurse() {
        window.requestAnimationFrame(() => {
          _render();

          recurse();
        }, -1);
      })();
    }

    const _handleDefaultKey = (code, shiftKey) => {
      let c = String.fromCharCode(code);
      if (shiftKey) {
        c = c.toUpperCase();
      }
      keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + c + keyboardState.text.slice(keyboardState.cursor);
      keyboardState.cursor++;
      menuMesh.urlMesh.updateText();
    };
    const _handleKey = (code, shiftKey) => {
      if (code === 8) { // backspace
        if (keyboardState.cursor > 0) {
          keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor - 1) + keyboardState.text.slice(keyboardState.cursor);
          keyboardState.cursor--;
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 46) { // delete
        if (keyboardState.cursor < keyboardState.text.length) {
          keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + keyboardState.text.slice(keyboardState.cursor + 1);
          menuMesh.urlMesh.updateText();
        }
      } else if (code === 32) { // space
        keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + ' ' + keyboardState.text.slice(keyboardState.cursor);
        keyboardState.cursor++;
        menuMesh.urlMesh.updateText();
      } else if (code === 13) { // enter
        keyboardState.submit();
      } else if (
        code === 9 || // tab
        code === 16 || // shift
        code === 17 || // ctrl
        code === 18 || // alt
        code === 20 || // capslock
        code === 27 || // esc
        code === 91 // win
      ) {
        // nothing
      } else if (code === 37) { // left
        keyboardState.cursor = Math.max(keyboardState.cursor - 1, 0);
        menuMesh.urlMesh.updateText();
      } else if (code === 39) { // right
        keyboardState.cursor = Math.min(keyboardState.cursor + 1, keyboardState.text.length);
        menuMesh.urlMesh.updateText();
      } else if (code === 38) { // up
        keyboardState.cursor = 0;
        menuMesh.urlMesh.updateText();
      } else if (code === 40) { // down
        keyboardState.cursor = keyboardState.text.length;
        menuMesh.urlMesh.updateText();
      } else if (code === -1) {
        // nothing
      } else {
        _handleDefaultKey(code, shiftKey);
      }
    };

    let iframes = [];
    const _openUrl = u => {
      const _drawOk = () => {
        loadingBarState.loading = false;
        loadingBarState.loaded = true;
        loadingBarState.error = false;
        loadingBarState.text = 'Load ok: ' + u;
        menuMesh.urlMesh.updateText();
      };
      const _drawFail = () => {
        loadingBarState.loading = false;
        loadingBarState.loaded = true;
        loadingBarState.error = true;
        loadingBarState.text = 'Load error: ' + u;
        menuMesh.urlMesh.updateText();
      };

      const iframe = document.createElement('iframe');
      iframe.onload = function() {
        const contentDocument = (() => {
          try {
            if (this.contentDocument) { // this potentially throws
              return this.contentDocument;
            } else {
              return null;
            }
          } catch(err) {
            console.warn(err.stack);
            return null;
          }
        })();
        if (contentDocument) {
          _drawOk();

          if (contentDocument.resources) {
            iframeResources = iframe.contentWindow.document.resources;
            resources.push(iframeResources);

            iframeResources.addEventListener('update', _resourcesUpdate);
          }

          floorMesh.visible = false;
          scene.background = null;
        } else {
          _closeUrl(iframe);
          iframes.splice(iframes.indexOf(iframe), 1);

          const index = currentApps.indexOf(iframe.src);
          if (index !== -1) {
            currentApps.splice(index, 1);
          }

          _drawFail();
        }
      };
      iframe.src = u;
      iframe.hidden = true;
      let iframeResources = null;
      iframe.addEventListener('framebuffer', newFramebuffer => {
        framebuffer = newFramebuffer;

        if (framebuffer) {
          screenQuad.material.uniforms.numTextures.value = 2;

          const colorTexture = new THREE.Texture();
          const colorProperties = renderer.properties.get(colorTexture);
          colorProperties.__webglTexture = {
            id: framebuffer.colorTexture,
          };
          colorProperties.__webglInit = true;
          screenQuad.material.uniforms.uTexture2.value = colorTexture;

          const depthTexture = new THREE.Texture();
          const depthProperties = renderer.properties.get(depthTexture);
          depthProperties.__webglTexture = {
            id: framebuffer.depthStencilTexture,
          };
          depthProperties.__webglInit = true;
          screenQuad.material.uniforms.uDepth2.value = depthTexture;
        } else {
          screenQuad.material.uniforms.numTextures.value = 1;
          screenQuad.material.uniforms.uTexture2.value = null;
          screenQuad.material.uniforms.uDepth2.value = null;
        }
      });
      iframe.addEventListener('destroy', () => {
        if (iframeResources) {
          resources.splice(resources.indexOf(iframeResources), 1);
        }

        floorMesh.visible = true;
        scene.background = _makeBackground();
      });
      container.appendChild(iframe);

      return iframe;
    };
    const _closeUrl = iframe => {
      if (iframe.destroy) {
        iframe.destroy();
      }

      container.removeChild(iframe);
    };
    const _updateLocalApps = () => {
      const iframesToKeep = [];
      for (let i = 0; i < iframes.length; i++) {
        const iframe = iframes[i];

        if (currentApps.includes(iframe.src)) {
          iframesToKeep.push(iframe);
        } else {
          _closeUrl(iframe);
          iframes.splice(iframes.indexOf(iframe), 1);
        }
      }
      iframes = iframesToKeep;

      let appsUpdated = false;
      for (let i = 0; i < currentApps.length; i++) {
        const currentApp = currentApps[i];

        if (!iframes.includes(currentApp)) {
          const iframe = _openUrl(currentApp);
          iframes.push(iframe);
        }
        if (!apps.includes(currentApp)) {
          apps.unshift(currentApp);
          appsUpdated = true;
        }
      }
      if (appsUpdated) {
        menuMesh.urlMesh.updateText();
      }
    };

    window.addEventListener('resize', e => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      camera.projectionMatrix.toArray(fakeDisplay._frameData.leftProjectionMatrix);
      camera.projectionMatrix.toArray(fakeDisplay._frameData.rightProjectionMatrix);

      const device = renderer.vr.getDevice();
      if (device === fakeDisplay) {
        renderer.vr.setDevice(null);
        renderer.vr.setAnimationLoop(null);
      }
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      if (device === fakeDisplay) {
        renderer.vr.setDevice(fakeDisplay);
        renderer.vr.setAnimationLoop(animate);
      }
    });

    let displays = [];
    const _updateDisplays = () => {
      Promise.all([
        window.navigator.getVRDisplays ? window.navigator.getVRDisplays() : Promise.resolve([]),
        window.navigator.xr ? window.navigator.xr.requestDevice().then(device => [device]) : Promise.resolve([]),
      ])
        .then(ds => {
          displays.length = 0;
          for (let i = 0; i < ds.length; i++) {
            displays.push.apply(displays, ds[i]);
          }
        })
        .catch(err => {
          console.warn(err);
        });
    };
    _updateDisplays();
    window.addEventListener('vrdisplayconnect', _updateDisplays);
    window.addEventListener('vrdisplaydisconnect', _updateDisplays);

    const resources = [];
    const _resourcesUpdate = () => {
      let value = 0;
      let total =  0;
      for (let i = 0; i < resources.length; i++) {
        for (let j = 0; j < resources[i].resources.length; j++) {
          const resource = resources[i].resources[j];
          value += resource.value;
          total += resource.total;
        }
      }
      loadingBarState.value = value;
      loadingBarState.total = total;
      loadingBarState.progress = loadingBarState.total > 0 ? (loadingBarState.value/loadingBarState.total) : 0;
      menuMesh.urlMesh.updateText();
    };
    if (window.document.resources) {
      resources.push(window.document.resources);
    }
    for (let i = 0; i < resources.length; i++) {
      window.document.resources.addEventListener('update', _resourcesUpdate);
    }

    const audioCtx = new AudioContext({
      sampleRate: 48000,
    });
    THREE.AudioContext.setContext(audioCtx);

    const _isPrintableKey = code =>
      code !== 13 && // enter
      code !== 8 && // backspace
      code !== 46 && // delete
      code !== 9 && // tab
      code !== 16 && // shift
      code !== 17 && // ctrl
      code !== 18 && // alt
      code !== 20 && // capslock
      code !== 27 && // esc
      code !== 91 && // win
      !(code >= 37 && code <= 40); // arrows

    window.addEventListener('keypress', e => {
      if (!window.document.pointerLockElement) {
        switch (e.which) {
          case 99: { // C
            if (e.ctrlKey) {
              document.execCommand('copy');
            } else {
              _handleKey(e.which, e.shiftKey);
            }
            break;
          }
          case 118: { // V
            if (e.ctrlKey) {
              document.execCommand('paste');
            } else {
              _handleKey(e.which, e.shiftKey);
            }
            break;
          }
          default: {
            if (!e.ctrlKey) {
              let c = String.fromCharCode(e.which);
              if (e.shiftKey) {
                c = c.toUpperCase();
              }
              keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + c + keyboardState.text.slice(keyboardState.cursor);
              keyboardState.cursor++;
              menuMesh.urlMesh.updateText();
            }
            break;
          }
        }
      } else {
        switch (e.which) {
          case 120: { // X
            for (let i = 0; i < controllerOffsets.length; i++) {
              controllerOffsets[i].set(0, 0, 0);
            }
            break;
          }
        }
      }
    });
    window.addEventListener('keydown', e => {
      const _handleDefaultKey = () => {
        if (window.document.pointerLockElement) {
          switch (e.which) {
            case 87: { // W
              keys.up = true;
              if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              }
              break;
            }
            case 83: { // S
              keys.down = true;
              if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              }
              break;
            }
            case 65: { // A
              keys.left = true;
              if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              }
              break;
            }
            case 68: { // D
              keys.right = true;
              if (!window.document.pointerLockElement) {
                renderer.domElement.requestPointerLock();
              }
              break;
            }
            case 67: { // C
              lastPresseds[controllerIndex] = false;
              lastMenuPresseds[controllerIndex] = false;
              lastGrabbeds[controllerIndex] = false;

              controllerMeshes[controllerIndex].rayMesh.visible = false;
              controllerMeshes[controllerIndex].rayDot.visible = false;
              controllerMeshes[controllerIndex].keyMesh.visible = false;
              const gamepad = fakeDisplay.gamepads[controllerIndex];
              for (let i = 0; i < 4; i++) {
                gamepad.buttons[i].value = 0;
                gamepad.buttons[i].pressed = false;
              }
              controllerIndex = 1;
              if (menuOpen) {
                controllerMeshes[controllerIndex].rayMesh.visible = true;
              }
              break;
            }
            case 90: { // Z
              lastPresseds[controllerIndex] = false;
              lastMenuPresseds[controllerIndex] = false;
              lastGrabbeds[controllerIndex] = false;

              controllerMeshes[controllerIndex].rayMesh.visible = false;
              controllerMeshes[controllerIndex].rayDot.visible = false;
              controllerMeshes[controllerIndex].keyMesh.visible = false;
              const gamepad = fakeDisplay.gamepads[controllerIndex];
              for (let i = 0; i < 4; i++) {
                gamepad.buttons[i].value = 0;
                gamepad.buttons[i].pressed = false;
              }
              controllerIndex = 0;
              if (menuOpen) {
                controllerMeshes[controllerIndex].rayMesh.visible = true;
              }
              break;
            }
            case 69: { // E
              fakeDisplay.gamepads[controllerIndex].buttons[3].value = 1;
              fakeDisplay.gamepads[controllerIndex].buttons[3].pressed = true;
              break;
            }
            case 70: { // F
              fakeDisplay.gamepads[controllerIndex].buttons[2].value = 1;
              fakeDisplay.gamepads[controllerIndex].buttons[2].pressed = true;
              break;
            }
            case 81: { // Q
              fakeDisplay.gamepads[controllerIndex].buttons[0].value = 1;
              fakeDisplay.gamepads[controllerIndex].buttons[0].pressed = true;
              break;
            }
            case 84: { // T
              if (_isMpOpen() && !voicechatEnabled && !xrmp.localPlayerMesh.getMediaStream()) {
                _openMic();
              }
              break;
            }
            case 17: { // Ctrl
              keys.ctrl = true;
              break;
            }
            case 18: { // Alt
              keys.alt = true;
              break;
            }
          }
        } else {
          if (!_isPrintableKey(e.which)) {
            _handleKey(e.which, e.shiftKey);
          }
        }
      };

      if (e.ctrlKey) {
        switch (e.which) {
          case 49: { // 1
            console.log('enable VR');

            const display = displays.find(display =>
              display.constructor.name === 'XRDevice'
            );

            if (display) {
              if (window.document.pointerLockElement) {
                window.document.exitPointerLock();
              }
              renderer.vr.setDevice(null);
              renderer.vr.setAnimationLoop(null);

              fakeDisplay.session.end()
                .then(() =>
                  display.requestSession({
                    exclusive: true,
                  })
                    .then(session => {
                      display.session = session;

                      session.requestAnimationFrame((timestamp, frame) => {
                        renderer.vr.setSession(session, {
                          frameOfReferenceType: 'stage',
                        });

                        const viewport = session.baseLayer.getViewport(frame.views[0]);
                        const width = viewport.width;
                        const height = viewport.height;

                        renderer.setSize(width * 2, height);

                        renderer.vr.setDevice(display);
                        renderer.vr.setAnimationLoop(animate);

                        renderTarget = _makeRenderTarget(width * 2, height);

                        screenQuad.material.uniforms.uTexture1.value = renderTarget.texture;
                        screenQuad.material.uniforms.uDepth1.value = renderTarget.depthTexture;
                      });
                    })
                )
                .catch(err => {
                  console.warn(err.stack);
                });
            }
            break;
          }
          case 50: { // 2
            console.log('enable ML');

            const display = displays.find(display =>
              display.constructor.name === 'MLDisplay'
            );
            if (display) {
              if (window.document.pointerLockElement) {
                window.document.exitPointerLock();
              }
              renderer.vr.setDevice(null);
              renderer.vr.setAnimationLoop(null);

              fakeDisplay.session.end();

              display.requestPresent([{source: canvas}])
                .then(() => {
                  renderer.vr.setDevice(display);
                  renderer.vr.setAnimationLoop(animate);

                  scene.background = null;
                });
            }
            break;
          }
          case 52: { // 4
            console.log('enable stereo');

            const newStereo = !fakeDisplay.getStereo();
            fakeDisplay.setStereo(newStereo);
            _enterFakeDisplay(newStereo);
            break;
          }
          default: {
            _handleDefaultKey();
            break;
          }
        }
      } else {
        _handleDefaultKey();
      }
    });
    window.addEventListener('keyup', e => {
      if (window.document.pointerLockElement) {
        switch (e.which) {
          case 87: { // W
            keys.up = false;
            break;
          }
          case 83: { // S
            keys.down = false;
            break;
          }
          case 65: { // A
            keys.left = false;
            break;
          }
          case 68: { // D
            keys.right = false;
            break;
          }
          case 69: { // E
            fakeDisplay.gamepads[controllerIndex].buttons[3].value = 0;
            fakeDisplay.gamepads[controllerIndex].buttons[3].pressed = false;
            break;
          }
          case 70: { // F
            fakeDisplay.gamepads[controllerIndex].buttons[2].value = 0;
            fakeDisplay.gamepads[controllerIndex].buttons[2].pressed = false;
            break;
          }
          case 81: { // Q
            fakeDisplay.gamepads[controllerIndex].buttons[0].value = 0;
            fakeDisplay.gamepads[controllerIndex].buttons[0].pressed = false;
            break;
          }
          case 84: { // T
            if (_isMpOpen() && !voicechatEnabled && xrmp.localPlayerMesh.getMediaStream()) {
              _closeMic();
            }
            break;
          }
          case 17: { // Ctrl
            keys.ctrl = false;
            break;
          }
          case 18: { // Alt
            keys.alt = false;
            break;
          }
        }
      }
    });
    window.addEventListener('mousedown', () => {
      if (!window.document.pointerLockElement) {
        renderer.domElement.requestPointerLock();
      } else {
        const gamepad = fakeDisplay.gamepads[1];
        if (gamepad) {
          fakeDisplay.gamepads[controllerIndex].buttons[1].value = 1;
          fakeDisplay.gamepads[controllerIndex].buttons[1].pressed = true;
        }
      }
    });
    window.addEventListener('mouseup', () => {
      const gamepad = fakeDisplay.gamepads[controllerIndex];
      if (gamepad) {
        gamepad.buttons[1].value = 0;
        gamepad.buttons[1].pressed = false;
      }
    });
    window.addEventListener('mousemove', e => {
      if (window.document.pointerLockElement) {
        const {movementX, movementY} = e;

        if (keys.ctrl) {
          const controllerOffset = controllerOffsets[controllerIndex];
          controllerOffset.x += movementX * 0.002;
          controllerOffset.y -= movementY * 0.002;
        } else if (keys.alt) {
          const controllerOffset = controllerOffsets[controllerIndex];
          controllerOffset.x += movementX * 0.002;
          controllerOffset.z += movementY * 0.002;
        } else {
          localEuler.setFromQuaternion(fakeDisplay.quaternion, localEuler.order);
          localEuler.y -= movementX * 0.01;
          localEuler.x -= movementY * 0.01;
          localEuler.x = Math.min(Math.max(localEuler.x, -Math.PI/2), Math.PI/2);
          fakeDisplay.quaternion.setFromEuler(localEuler);

          fakeDisplay.update();
        }

        _updateGamepads();
      }
    });
    window.document.addEventListener('pointerlockchange', e => {
      if (!window.document.pointerLockElement) {
        for (const k in keys) {
          keys[k] = false;
        }
      }
    });
    window.document.addEventListener('paste', e => {
      const {clipboardData} = e;
      const items = Array.from(clipboardData.items);
      const item = items.find(item => item.kind === 'string');
      if (item) {
        item.getAsString(s => {
          keyboardState.text = keyboardState.text.slice(0, keyboardState.cursor) + s + keyboardState.text.slice(keyboardState.cursor);
          keyboardState.cursor += s.length;
          menuMesh.urlMesh.updateText();
        });
      }
    });
    window.addEventListener('dragover', e => {
      e.preventDefault();
    });
    const _getFiles = dataTransfer => {
      if (dataTransfer.items.length > 0) {
        const entries = Array.from(items)
          .map(item => item.webkitGetAsEntry())
          .filter(entry => entry !== null);

        const files = [];
        const _recurseEntries = entries => Promise.all(entries.map(_recurseEntry));
        const _recurseEntry = entry => new Promise((accept, reject) => {
          if (entry.isFile) {
            entry.file(file => {
              file.path = entry.fullPath.slice(1);

              files.push(file);

              accept();
            });
          } else if (entry.isDirectory) {
            const directoryReader = entry.createReader();
            directoryReader.readEntries(entries => {
              _recurseEntries(Array.from(entries))
                .then(() => {
                  accept();
                });
            });
          } else {
            accept();
          }
        });
        return _recurseEntries(entries)
          .then(() => files);
      } else {
        return Promise.resolve(dataTransfer.files);
      }
    };
    const _uploadFile = file => {
      const dropPositon = camera.position.clone()
        .add(
          localVector.set(0, 0, -0.4)
            .applyQuaternion(camera.quaternion)
        );

      return xrid.upload(file)
        .then(result => {
          const fileObject = _makeFileObject({
            url: result.url,
          });
          fileObject.position.copy(dropPositon);
          scene.add(fileObject);
          fileMeshes.push(fileObject);

          return xrid.getFiles()
            .then(newFiles => {
              files = newFiles;

              menuMesh.urlMesh.updateText();
            });
        });
    };
    window.addEventListener('drop', e => {
      e.preventDefault();

      if (_isIdOpen()) {
        const {dataTransfer} = e;
        if (dataTransfer.files.length > 0) {
          if (dataTransfer.files.length > 1) {
            _getFiles(dataTransfer)
              .then(files => {
                const tar = new Tar();
                const _recurse = i => {
                  if (i < files.length) {
                    const file = files[i];

                    const fr = new FileReader();
                    fr.onload = () => {
                      tar.append(file.path.replace(/^[A-Z]:/, '').replace(/\\/g, '/'), new Uint8Array(fr.result), () => {
                        _recurse(i + 1);
                      });
                    };
                    fr.onerror = err => {
                      console.warn(err.stack);
                    };
                    fr.readAsArrayBuffer(file);
                  } else {
                    const bestFile = files.find(file => /\.fbx/.test(file.name)) || files[0];
                    const blob = new Blob([tar.out], {
                      type: 'application/x-tar',
                    });
                    blob.name = bestFile.name + '.tar';

                    _uploadFile(blob)
                      .then(() => {
                        console.log('done upload', blob.name);
                      })
                      .catch(err => {
                        console.warn(err);
                      });
                  }
                };
                _recurse(0);
              })
              .catch(err => {
                console.warn(err.stack);
              });
          } else {
            _uploadFile(dataTransfer.files[0])
              .catch(err => {
                console.warn(err);
              });
          }
        }
      }
    });
})();
  </script>
</body>
</html>
